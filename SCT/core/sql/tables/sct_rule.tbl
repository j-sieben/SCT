create table sct_rule(
  sru_id number, 
	sru_sgr_id number, 
	sru_name varchar2(50 char), 
	sru_condition clob,
	sru_sort_seq number, 
	sru_firing_items varchar2(300 byte),
  sru_fire_on_page_load number(1,0) default -1,
  sru_has_error number(1,0) default 0,
  sru_active number(1,0) default 1,
  constraint sct_rules_pk primary key (sru_id, sru_sgr_id),
  constraint sru_sgr_id_fk foreign key (sru_sgr_id)
	  references sct_rule_group (sgr_id) on delete cascade,
  constraint sru_fire_on_page_load_chk check(sru_fire_on_page_load in (-1,1)),
  constraint sru_has_error_chk check(sru_has_error in (0,1)),
  constraint sru_active_chk check(sru_active in (0,1))
) organization index;

create index sru_sgr_id_fk_idx on sct_rule(sru_sgr_id, sru_id);

create or replace trigger trg_bri_sct_rule 
  before insert on sct_rule
  for each row
begin
  /* TODO: refactor to IDENTITY-COLUMN if version 12c can be assumed! */
  :new.sru_id := coalesce(:new.sru_id, sct_seq.nextval);
end;
/

comment on table sct_rule is 'Table to store a single rule';
comment on column sct_rule.sru_id is 'PK, technical key';
comment on column sct_rule.sru_sgr_id is 'FK, reference to SCT_GROUP';
comment on column sct_rule.sru_name is 'Descriptive Name';
comment on column sct_rule.sru_condition is 'Condition, syntactically in the form of a partial where-clause';
comment on column sct_rule.sru_firing_items is 'List of page items that are referenced within sru_condition';
comment on column sct_rule.sru_fire_on_page_load is 'Flag to indicate that this rule should be executed on page initialization';
comment on column sct_rule.sru_sort_seq is 'Sort criteria, defines execution sequence';
comment on column sct_rule.sru_has_error is 'Flag to indicate whether rule has validation error';
comment on column sct_rule.sru_active is 'Flag to indicate whether rule is in use';
